{"version":3,"sources":["modules/affix.js"],"names":["angular","windowEl","$window","defaults","AffixFactory","offsetTop","$affix","inlineStyles","options","this","$get","reset","setWidth","initialAffixTop","offsetParent","match","getRequiredAffixClass","unpin","position","top","scrollTop","getScrollTop","scrollHeight","getScrollHeight","targetEl","pageYOffset","directive","document","parent","target","initialOffsetTop","offsetBottom","affixed","element","init","i","dimensions","on","checkPositionWithEventLoop","require","offset","destroy","style","width","off","checkPosition","$parseOffsets","elementHeight","height","setTimeout","affix","css","addClass","offsetUnpin","offsetWidth","$debouncedOnResize","$onResize","initialPosition","restrict","affixTarget","$element","forEach","link","key","scope","option","$on","attr","test","controller"],"mappings":"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","file":"modules/affix.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.affix', ['mgcrea.ngStrap.helpers.dimensions', 'mgcrea.ngStrap.helpers.debounce'])\n\n  .provider('$affix', function() {\n\n    var defaults = this.defaults = {\n      offsetTop: 'auto',\n      inlineStyles: true\n    };\n\n    this.$get = function($window, debounce, dimensions) {\n\n      var bodyEl = angular.element($window.document.body);\n      var windowEl = angular.element($window);\n\n      function AffixFactory(element, config) {\n\n        var $affix = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        var targetEl = options.target;\n\n        // Initial private vars\n        var reset = 'affix affix-top affix-bottom',\n            setWidth = false,\n            initialAffixTop = 0,\n            initialOffsetTop = 0,\n            offsetTop = 0,\n            offsetBottom = 0,\n            affixed = null,\n            unpin = null;\n\n        var parent = element.parent();\n        // Options: custom parent\n        if (options.offsetParent) {\n          if (options.offsetParent.match(/^\\d+$/)) {\n            for (var i = 0; i < (options.offsetParent * 1) - 1; i++) {\n              parent = parent.parent();\n            }\n          }\n          else {\n            parent = angular.element(options.offsetParent);\n          }\n        }\n\n        $affix.init = function() {\n\n          initialOffsetTop = dimensions.offset(element[0]).top + initialAffixTop;\n          setWidth = !element[0].style.width;\n\n          // Bind events\n          targetEl.on('scroll', this.checkPosition);\n          targetEl.on('click', this.checkPositionWithEventLoop);\n          windowEl.on('resize', this.$debouncedOnResize);\n\n          // Both of these checkPosition() calls are necessary for the case where\n          // the user hits refresh after scrolling to the bottom of the page.\n          this.checkPosition();\n          this.checkPositionWithEventLoop();\n\n        };\n\n        $affix.destroy = function() {\n\n          // Unbind events\n          targetEl.off('scroll', this.checkPosition);\n          targetEl.off('click', this.checkPositionWithEventLoop);\n          windowEl.off('resize', this.$debouncedOnResize);\n\n        };\n\n        $affix.checkPositionWithEventLoop = function() {\n\n          // IE 9 throws an error if we use 'this' instead of '$affix'\n          // in this setTimeout call\n          setTimeout($affix.checkPosition, 1);\n\n        };\n\n        $affix.checkPosition = function() {\n          // if (!this.$element.is(':visible')) return\n\n          //parse offsets whenever check position\n          $affix.$parseOffsets();\n\n          var scrollTop = getScrollTop();\n          var position = dimensions.offset(element[0]);\n          var elementHeight = dimensions.height(element[0]);\n\n          // Get required affix class according to position\n          var affix = getRequiredAffixClass(unpin, position, elementHeight);\n\n          // Did affix status changed this last check?\n          if(affixed === affix) return;\n          affixed = affix;\n\n          // Add proper affix class\n          element.removeClass(reset).addClass('affix' + ((affix !== 'middle') ? '-' + affix : ''));\n\n          if(affix === 'top') {\n            unpin = null;\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.css('top', '');\n            }\n          } else if(affix === 'bottom') {\n            if (options.offsetUnpin) {\n              unpin = -(options.offsetUnpin * 1);\n            }\n            else {\n              // Calculate unpin threshold when affixed to bottom.\n              // Hopefully the browser scrolls pixel by pixel.\n              unpin = position.top - scrollTop;\n            }\n            if(setWidth) {\n              element.css('width', '');\n            }\n            if (options.inlineStyles) {\n              element.css('position', (options.offsetParent) ? '' : 'relative');\n              element.offset({ top: options.offsetParent ? '' : (getScrollHeight() - offsetBottom - elementHeight) });\n              // element.css('top', (options.offsetParent) ? '' : ((bodyEl[0].offsetHeight - offsetBottom - elementHeight - initialOffsetTop) + 'px'));\n            }\n          } else { // affix === 'middle'\n            unpin = null;\n            if(setWidth) {\n              element.css('width', element[0].offsetWidth + 'px');\n            }\n            if (options.inlineStyles) {\n              element.css('position', 'fixed');\n              element.css('top', initialAffixTop + 'px');\n            }\n          }\n\n        };\n\n        $affix.$onResize = function() {\n          $affix.$parseOffsets();\n          $affix.checkPosition();\n        };\n        $affix.$debouncedOnResize = debounce($affix.$onResize, 50);\n\n        $affix.$parseOffsets = function() {\n          var initialPosition = element.css('position');\n          // Reset position to calculate correct offsetTop\n          if (options.inlineStyles){\n            element.css('position', (options.offsetParent) ? '' : 'relative');\n          }\n\n          if(options.offsetTop) {\n            if(options.offsetTop === 'auto') {\n              options.offsetTop = '+0';\n            }\n            if(options.offsetTop.match(/^[-+]\\d+$/)) {\n              initialAffixTop = - options.offsetTop * 1;\n              if(options.offsetParent) {\n                offsetTop = dimensions.offset(parent[0]).top + (options.offsetTop * 1);\n              }\n              else {\n                offsetTop = dimensions.offset(element[0]).top - dimensions.css(element[0], 'marginTop', true) + (options.offsetTop * 1);\n              }\n            }\n            else {\n              offsetTop = options.offsetTop * 1;\n            }\n          }\n\n          if(options.offsetBottom) {\n            if(options.offsetParent && options.offsetBottom.match(/^[-+]\\d+$/)) {\n              // add 1 pixel due to rounding problems...\n              offsetBottom = getScrollHeight() - (dimensions.offset(parent[0]).top + dimensions.height(parent[0])) + (options.offsetBottom * 1) + 1;\n            }\n            else {\n              offsetBottom = options.offsetBottom * 1;\n            }\n          }\n\n          // Bring back the element's position after calculations\n          if (options.inlineStyles){\n            element.css('position', initialPosition);\n          }\n        };\n\n        // Private methods\n\n        function getRequiredAffixClass(unpin, position, elementHeight) {\n\n          var scrollTop = getScrollTop();\n          var scrollHeight = getScrollHeight();\n\n          if(scrollTop <= offsetTop) {\n            return 'top';\n          } else if(unpin !== null && (scrollTop + unpin <= position.top)) {\n            return 'middle';\n          } else if(offsetBottom !== null && (position.top + elementHeight + initialAffixTop >= scrollHeight - offsetBottom)) {\n            return 'bottom';\n          } else {\n            return 'middle';\n          }\n\n        }\n\n        function getScrollTop() {\n          return targetEl[0] === $window ? $window.pageYOffset : targetEl[0].scrollTop;\n        }\n\n        function getScrollHeight() {\n          return targetEl[0] === $window ? $window.document.body.scrollHeight : targetEl[0].scrollHeight;\n        }\n\n        $affix.init();\n        return $affix;\n\n      }\n\n      return AffixFactory;\n\n    };\n\n  })\n\n  .directive('bsAffix', function($affix, $window) {\n\n    return {\n      restrict: 'EAC',\n      require: '^?bsAffixTarget',\n      link: function postLink(scope, element, attr, affixTarget) {\n\n        var options = {scope: scope, target: affixTarget ? affixTarget.$element : angular.element($window)};\n        angular.forEach(['offsetTop', 'offsetBottom', 'offsetParent', 'offsetUnpin', 'inlineStyles'], function(key) {\n          if(angular.isDefined(attr[key])) {\n            var option = attr[key];\n            if (/true/i.test(option)) option = true;\n            if (/false/i.test(option)) option = false;\n            options[key] = option;\n          }\n        });\n\n        var affix = $affix(element, options);\n        scope.$on('$destroy', function() {\n          affix && affix.destroy();\n          options = null;\n          affix = null;\n        });\n\n      }\n    };\n\n  })\n\n  .directive('bsAffixTarget', function() {\n    return {\n      controller: function($element) {\n        this.$element = $element;\n      }\n    };\n  });\n"],"sourceRoot":"/source/"}